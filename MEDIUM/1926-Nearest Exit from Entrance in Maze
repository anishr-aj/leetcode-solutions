class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        int rows = maze.length;
        int cols = maze[0].length;
        final int[] directions = {-1, 0, 1, 0, -1};

        Deque<int[]> queue = new ArrayDeque<>();
        queue.offer(entrance);

        maze[entrance[0]][entrance[1]] = '+';

        for (int distance = 1; !queue.isEmpty(); distance++) {
            int currentLevelSize = queue.size();

            for (int i = 0; i < currentLevelSize; i++) {
                int[] currentPosition = queue.poll();

                for (int dir = 0; dir < 4; dir++) {
                    int newRow = currentPosition[0] + directions[dir];
                    int newCol = currentPosition[1] + directions[dir + 1];

                    if (newRow >= 0 && newRow < rows &&
                        newCol >= 0 && newCol < cols &&
                        maze[newRow][newCol] == '.') {

                        if (newRow == 0 || newRow == rows - 1 ||
                            newCol == 0 || newCol == cols - 1) {
                            return distance;
                        }

                        maze[newRow][newCol] = '+';
                        queue.offer(new int[] {newRow, newCol});
                    }
                }
            }
        }

        return -1;
    }
}
